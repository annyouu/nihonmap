## 概要 (日本工業大学　最短経路マップナビゲーター)
本プロジェクトは、OSM（OpenStreetMap）データを利用し、日本工業大学キャンパス内の歩行者向け最短経路を強化学習(Q学習)を使って探索するWebアプリです。
今はQ学習を利用していますが、Sarsaなどにも拡張できたらと思っております。
フロントエンドは React + Leaflet で地図を表示し、バックエンドは FastAPI + NetworkX + OSMnx で経路計算を行います。
Q学習を用いた強化学習アルゴリズムで経路を学習し、失敗時はダイクストラ法で最短経路を計算します。

### ダイクストラ法とは？
スタート地点からゴールノードへの最短経路を求めるアルゴリズムである。
エッジ(重み)がついている経路の中から、最も短いルートを見つける方法。
今回では、NetworkXライブラリを使って最短経路を算出している。

### なぜダイクストラ法を採用している？
主として、Q学習を使って最短経路を出すことを目的としていますが、学習が常にうまくいくとは限らないです。
Q学習が失敗した時のことを考えて、最短経路算出として優秀なアルゴリズム、ダイクストラ法を採用しました。
つまり、ダイクストラ法は「正解の最短経路」を出して比較したり、学習を助けたりするために使われています。



## 技術スタック
| 種類      | 技術                                        |
| ------- | ----------------------------------------- |
| フロントエンド | React, TypeScript, react-leaflet, Leaflet |
| バックエンド  | Python, FastAPI, NetworkX, OSMnx          |
| 通信      | REST API (JSON)                           |

### react-leaflet, Leaflet ってどういうもの？
1. Leaflet
- 地図ライブラリで、ブラウザ上で地図を表示できたり、マーカーなどをクリックで簡単に描画することができる。

2. React-Leaflet
- ReactでLeafletを扱いやすくするためのライブラリ
    - Reactの状態管理 (useState, useEffect)と連携がしやすい。
    - Leafletのイベント(クリック、ドラック)をReactの関数で行える。 

今回は、OSmnxとLeafletを組み合わせて、地図データを表現しました。

### なぜ OSMnx + Leafletを組み合わせたのか？
- 理由：OSMnx + Leafletとそれぞれの役割を明確に分離できると思ったためです。

#### OSMnx
OSMnx は、OpenStreetMap から道路ネットワークを取得し、ノード・エッジで構成されたグラフとして扱えるライブラリです。
こちらは、データ取得・計算処理させるためのデータ加工に最適です。なので、最短経路の算出するためのデータ取得という役割を持たせました。
しかし、最短経路を可視化させる部分、UIとしての強みはないと言った問題がありました。
そこで地図表示に特化した「React-Leaflet」を加えました。

#### Leaflet / React-Leaflet
こちらは、可視化・ユーザー操作をするためのUIとしての役割を持たせました。
React-Leaflet は、Leafletというを React のコンポーネントとして扱えるようにするラッパーライブラリです。
- React の状態管理（useState / useEffect）と統合しやすい
- ユーザー操作（クリック・ドラッグなど）を React のイベントとして扱える
といったメリットがあり、Leftletを採用しました。

まとめると、
- OSMnx → データ取得、加工が行いやすため、Q学習で、最短経路を求めるのに最適である。
- Leaflet / React-Leaflet → ユーザーとの操作(UI)をReactを通じて実装が行える。

正確な経路計算 × 見やすく操作しやすい地図 UI操作を実現するためにこの2つを組み合わせました。

## プロジェクト構成
```bash
project/
├─ frontend/              # React
│   └─ src/
│       └─ WalkMap.tsx
├─ backend/               # FastAPI
│   └─ main.py
├─ README.md
└─ requirements.txt       # Python依存
```
現時点では、MVP(最小構成なので)、コンポーネントによる切り分けは行なっていません。
今後アプリが拡張される場合は、アーキテクチャ設計もしっかり取り入れたいと考えています。

# バックエンド仕様（FastAPI）
API一覧
| エンドポイント      | メソッド | 説明                       |
| ------------ | ---- | ------------------------ |
| `/api/nodes` | GET  | グラフ上の全ノード座標を取得           |
| `/api/edges` | GET  | グラフ上の全エッジ情報（始点・終点・距離）を取得 |
| `/api/train` | POST | 選択した始点・終点に対して経路探索を実行     |

## なぜPython(FastAPI)を採用したか？
理由は、2点あります。
1. 最短経路を求める際のデータ処理系ライブラリが圧倒的に豊富であるため。
最短経路探索では、地図データの取得・加工・グラフ構築・経路計算など、複数の処理を行う必要があります。
Python にはこの領域に適したライブラリが整っており、
- OSMnx（OpenStreetMap から道路ネットワークを取得・加工）
- NetworkX（グラフ構造を扱い、ダイクストラ法などの経路計算が可能）
といったライブラリをimportするだけで複雑な処理を簡潔に実装することができます。

2. FastAPIにより、API実装がシンプルに行えるため。
最短経路計算をAPI化するためには「入力されたデータを渡す → APIで最短距離を出す処理実行 → JSONレスポンスを返す」という流れを作る必要がありました。
FastAPI は、エンドポイントの定義からバリデーション、エンドポイント下に関数を定義し、処理を実装する、レスポンス生成までが直感的に書くことができるため、魅力的だと思いました。

つまり、「計算系ライブラリの豊富さ＋FastAPIによって単独APIを簡単に構築することができる部分」
この2点によって、今回Pyhton(FastAPI)を採用しました。

## /api/train リクエスト例
```bash
"start": { "lat": 36.0263, "lng": 139.7121 }, # スタート地点のクリック座標
"goal": { "lat": 36.0270, "lng": 139.7130 },  # ゴール地点のクリック座標
"episodes": 100,  # エピソード数
"alpha": 0.1, # 学習率
"gamma": 0.9 # 割引率
```

## /api/train レスポンス例
```bash
{
  "path": [
    {"lat": 36.0263, "lng": 139.7121},
    {"lat": 36.0265, "lng": 139.7125},
    {"lat": 36.0270, "lng": 139.7130}
  ],
  "distance": 120.5,
  "mapped_start": {"lat": 36.0263, "lng": 139.7121},
  "mapped_goal": {"lat": 36.0270, "lng": 139.7130},
  "algorithm": "Q-Learning (Fallback to Dijkstra)"
}
```

## バックエンドの詳細処理内容(関数について)
1. haversine_distance(lat1, lon1, lat2, lon2)
- 経度緯度から地球上の距離(メートル)を計算する

2. densify_curved_edges(G) 
- OSMnxの曲線道路を中間ノードで分割する
- より正確な距離計算と Q学習経路探索のために必要

3. connect_nearby_nodes_wrapper(G, threshold)
- 閾値以内のノード同士を接続する
- 道路が断裂している場合でも、歩行可能な近接経路を作る

4. nearest_node(lat, lng)
- 指定した座標に最も近いグラフ上のノードIDを返す
- フロントでクリックした座標をグラフにマッピングする

5. /api/nodes
- グラフ内のすべてのノードのIDと座標を返す

6. /api/edges
- グラフ内のすべてのエッジ情報(from, to, length)を返す

7. /api/train
実際に強化学習を行うAPI
- 入力座標から終了までの最短経路を求める


# フロントエンド仕様(主要機能)
- 地図表示（Leaflet + OpenStreetMap）
- マップクリックで始点・終点を選択
- 学習アルゴリズムを選択する
- 学習パラメータ設定 (エピソード数、学習率 α、割引率 γ)
- 経路描画 (赤線)
- 総距離表示

# フロント → バックエンドの通信
1. 初回ロード時：
- /api/nodes でノード取得
- /api/edges でエッジ取得
2. ユーザーが始点・終点を選択 → 「学習実行」ボタン押下：
- /api/train に POST
- 結果を Polyline としてマップ上に描画